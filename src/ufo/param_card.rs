//! Module to read param cards as described by the [`Supersymmetry Les Houches Accord`]
//! These param_cards can be used as inputs, as generated by the Python program
//! `write_param_card.py` that is bundled with UFO models.
//! Additionally, the restriction files that might come with models are in this format.
//!
//! [`Supersymmetry Les Houches Accord`]: https://arxiv.org/abs/hep-ph/0311123

use crate::ufo::{LhaBlock, LhaCode, PdgCode};
use nom::branch::alt;
use nom::bytes::complete::{tag_no_case, take_till1};
use nom::character::complete::{alpha1, char, line_ending, not_line_ending, space0, space1};
use nom::combinator::opt;
use nom::error::{convert_error, VerboseError};
use nom::multi::{count, many0, many1};
use nom::sequence::{pair, tuple};
use nom::Parser;
use std::collections::HashMap;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::str::FromStr;

/// A UFO param card in the SUSY lha format
pub struct ParamCard {
    blocks: HashMap<LhaBlock, HashMap<LhaCode, f64>>,
    decays: HashMap<PdgCode, Decays>,
}
impl ParamCard {
    pub fn read<P: AsRef<Path>>(path: &P) -> Result<ParamCard, ParamCardError> {
        let mut data = String::new();
        File::open(path)?.read_to_string(&mut data)?;
        ParamCard::parse(&data)
    }

    fn parse(data: &str) -> Result<ParamCard, ParamCardError> {
        let mut blocks = HashMap::new();
        let mut decays = HashMap::new();
        let mut i = data;
        while !i.is_empty() {
            let (j, bloc_or_decay) =
                read_block_or_decay(i).map_err(|err| ParamCardError::from_nom(data, err))?;
            match bloc_or_decay {
                BlockOrDecay::Block(name, block) => {
                    blocks.insert(name, block);
                }
                BlockOrDecay::Decay(pdg_code, decay) => {
                    decays.insert(pdg_code, decay);
                }
            }
            let (j, _) = many0(rest_of_line)(j)
                .expect("BUG: This parser should never fail, just not parse anything!");
            i = j;
        }
        Ok(ParamCard { blocks, decays })
    }

    pub fn lookup(&self, block: &LhaBlock, code: &LhaCode) -> Option<f64> {
        self.blocks.get(block).and_then(|b| b.get(code).copied())
    }
    pub fn lookup_decay(&self, pdg_code: PdgCode) -> Option<&Decays> {
        self.decays.get(&pdg_code)
    }
}

/// The decay information for a particle
#[derive(Clone, Debug, PartialEq)]
pub struct Decays {
    /// The decay width of the particle, in GeV
    width: f64,
    /// All decay channels for the particle
    channels: Vec<DecayChannel>,
}

/// A decay channel for a particle
#[derive(Clone, Debug, PartialEq)]
pub struct DecayChannel {
    /// The branching ratio for this channel
    branching_ratio: f64,
    /// The daughter particles produced in this decay channel
    daughters: Vec<PdgCode>,
}

/// Error type to indicate that `read`ing a ParamCard failed
#[derive(Debug)]
pub enum ParamCardError {
    /// An error occurred while reading the file
    IoError(std::io::Error),
    Parse(String),
}
impl ParamCardError {
    fn from_nom(input: &str, err: nom::Err<nom::error::VerboseError<&str>>) -> ParamCardError {
        let err = match err {
            nom::Err::Error(e) | nom::Err::Failure(e) => e,
            _ => unreachable!("BUG: The parsers should only use complete!"),
        };
        ParamCardError::Parse(convert_error(input, err))
    }
}
impl From<std::io::Error> for ParamCardError {
    fn from(err: std::io::Error) -> ParamCardError {
        ParamCardError::IoError(err)
    }
}

enum BlockOrDecay {
    Block(LhaBlock, HashMap<LhaCode, f64>),
    Decay(PdgCode, Decays),
}

fn read_block_or_decay(i: &str) -> nom::IResult<&str, BlockOrDecay, VerboseError<&str>> {
    alt((read_block, read_decay_block))(i)
}

fn read_block(i: &str) -> nom::IResult<&str, BlockOrDecay, VerboseError<&str>> {
    let (i, (name, block)) = pair(read_block_header.map(LhaBlock), read_block_body)(i)?;
    Ok((i, BlockOrDecay::Block(name, block)))
}

fn read_block_header(i: &str) -> nom::IResult<&str, String, VerboseError<&str>> {
    let (i, _) = many0(rest_of_line)(i)?;
    let (i, _) = tag_no_case("block")(i)?;
    let (i, _) = space1(i)?;
    let (i, name) = alpha1(i)?;
    let (i, _) = rest_of_line(i)?;
    Ok((i, name.to_ascii_lowercase()))
}

fn read_block_body(i: &str) -> nom::IResult<&str, HashMap<LhaCode, f64>, VerboseError<&str>> {
    let (i, lines) = many1(read_block_line)(i)?;
    let map = lines.into_iter().collect();
    Ok((i, map))
}

fn read_block_line(i: &str) -> nom::IResult<&str, (LhaCode, f64), VerboseError<&str>> {
    let (i, _) = many0(rest_of_line)(i)?;
    let (i, _) = space1(i)?;
    let (i, code) = parse_to(i)?;
    let (i, _) = space1(i)?;
    let (i, value) = parse_to(i)?;
    let (i, _) = space1(i)?;
    let (i, _) = rest_of_line(i)?;
    println!("{} {}", code, value);
    Ok((i, (LhaCode(code), value)))
}

fn read_decay_block(i: &str) -> nom::IResult<&str, BlockOrDecay, VerboseError<&str>> {
    let (i, ((pdg, width), channels)) = pair(read_decay_header, read_decay_body)(i)?;
    Ok((i, BlockOrDecay::Decay(pdg, Decays { width, channels })))
}

fn read_decay_header(i: &str) -> nom::IResult<&str, (PdgCode, f64), VerboseError<&str>> {
    let (i, _) = many0(rest_of_line)(i)?;
    let (i, _) = tag_no_case("decay")(i)?;
    let (i, _) = space1(i)?;
    let (i, pdg_code) = parse_to(i)?;
    let (i, _) = space1(i)?;
    let (i, width) = parse_to(i)?;
    let (i, _) = rest_of_line(i)?;
    Ok((i, (PdgCode(pdg_code), width)))
}

fn read_decay_body(i: &str) -> nom::IResult<&str, Vec<DecayChannel>, VerboseError<&str>> {
    many0(read_decay_channel)(i)
}

fn read_decay_channel(i: &str) -> nom::IResult<&str, DecayChannel, VerboseError<&str>> {
    let (i, _) = many0(rest_of_line)(i)?;
    let (i, branching_ratio) = parse_to(i)?;
    let (i, _) = space1(i)?;
    let (i, n) = parse_to(i)?;
    let (i, daughters) = count(read_daughter, n)(i)?;
    let (i, _) = rest_of_line(i)?;
    Ok((
        i,
        DecayChannel {
            branching_ratio,
            daughters,
        },
    ))
}

fn read_daughter(i: &str) -> nom::IResult<&str, PdgCode, VerboseError<&str>> {
    let (i, _) = space1(i)?;
    let (i, pdg_code) = parse_to(i)?;
    Ok((i, PdgCode(pdg_code)))
}

fn rest_of_line(i: &str) -> nom::IResult<&str, (), VerboseError<&str>> {
    let (i, _) = tuple((space0, opt(comment), line_ending))(i)?;
    Ok((i, ()))
}

fn comment(i: &str) -> nom::IResult<&str, &str, VerboseError<&str>> {
    let (i, _) = char('#')(i)?;
    not_line_ending(i)
}

fn parse_to<T: FromStr>(i: &str) -> nom::IResult<&str, T, VerboseError<&str>> {
    let (j, str) = take_till1(|b| b == ' ' || b == '\t' || b == '\n' || b == '\r')(i)?;
    let value: T = str.parse().map_err(|_| {
        nom::Err::Error(nom::error::VerboseError {
            errors: vec![(
                i,
                nom::error::VerboseErrorKind::Context("Failed to convert"),
            )],
        })
    })?;
    Ok((j, value))
}

#[cfg(test)]
mod test {
    use super::ParamCard;
    use crate::ufo::param_card::{LhaBlock, LhaCode};
    use crate::ufo::PdgCode;

    #[test]
    fn sm_mg5_default() {
        let card = ParamCard::read(&"tests/models/sm_mg5/restrict_default.dat").unwrap();
        assert_eq!(
            card.lookup(&LhaBlock("mass".to_string()), &LhaCode(6)),
            Some(173.0)
        );
    }

    #[test]
    fn sm_mg5_c_mass() {
        let card = ParamCard::read(&"tests/models/sm_mg5/restrict_c_mass.dat").unwrap();
        assert_eq!(
            card.lookup(&LhaBlock("mass".to_string()), &LhaCode(4)),
            Some(1.55)
        );
    }

    #[test]
    fn sm_mg5_ckm() {
        let card = ParamCard::read(&"tests/models/sm_mg5/restrict_ckm.dat").unwrap();
        assert_eq!(
            card.lookup(&LhaBlock("mass".to_string()), &LhaCode(11)),
            Some(0.0)
        );
    }

    #[test]
    fn sm_mg5_lepton_masses() {
        let card = ParamCard::read(&"tests/models/sm_mg5/restrict_lepton_masses.dat").unwrap();
        assert_eq!(card.lookup_decay(PdgCode(6)).unwrap().width, 1.491500);
    }

    #[test]
    fn sm_mg5_no_b_mass() {
        let card = ParamCard::read(&"tests/models/sm_mg5/restrict_no_b_mass.dat").unwrap();
        assert_eq!(
            card.lookup(&LhaBlock("yukawa".to_string()), &LhaCode(15)),
            Some(1.777)
        );
    }

    #[test]
    fn sm_mg5_no_masses() {
        let card = ParamCard::read(&"tests/models/sm_mg5/restrict_no_masses.dat").unwrap();
        assert_eq!(card.lookup_decay(PdgCode(25)).unwrap().channels, Vec::new());
    }

    #[test]
    fn sm_mg5_no_tau_mass() {
        let card = ParamCard::read(&"tests/models/sm_mg5/restrict_no_tau_mass.dat").unwrap();
        assert_eq!(
            card.lookup(&LhaBlock("wolfenstein".to_string()), &LhaCode(1)),
            Some(0.0)
        );
    }

    #[test]
    fn sm_mg5_no_widths() {
        let card = ParamCard::read(&"tests/models/sm_mg5/restrict_no_widths.dat").unwrap();
        assert_eq!(
            card.lookup(&LhaBlock("sminputs".to_string()), &LhaCode(1)),
            Some(132.5070)
        );
    }

    #[test]
    fn sm_mg5_zeromass_ckm() {
        let card = ParamCard::read(&"tests/models/sm_mg5/restrict_zeromass_ckm.dat").unwrap();
        assert_eq!(
            card.lookup(&LhaBlock("wolfenstein".to_string()), &LhaCode(1)),
            Some(2.253000e-01)
        );
    }
}
