/// Generates all possible combinations of sets of values
///
/// # Examples
///
/// All combinations of `[1,2]` and `[3,4]` are `[1,3]`, `[1,4]`, `[2,3]` and `[2,4]`.
/// These can be generated as follows:
/// ```
/// use helac_rs::util::Combinations;
///
/// let a = vec![1,2];
/// let b = vec![3,4];
/// let mut combinations = Combinations::new(vec![a,b]);
/// assert_eq!(combinations.next(), Some(vec![1,3]));
/// assert_eq!(combinations.next(), Some(vec![1,4]));
/// assert_eq!(combinations.next(), Some(vec![2,3]));
/// assert_eq!(combinations.next(), Some(vec![2,4]));
/// ```
///
/// The sets that are passed in do not have to be owned, in this case the output is then also
/// borrowed:
/// ```
/// use helac_rs::util::Combinations;
///
/// let a = &[1,2];
/// let b = &[3,4];
/// let mut combinations = Combinations::new(vec![a,b]);
/// assert_eq!(combinations.next(), Some(vec![&1,&3]));
/// assert_eq!(combinations.next(), Some(vec![&1,&4]));
/// assert_eq!(combinations.next(), Some(vec![&2,&3]));
/// assert_eq!(combinations.next(), Some(vec![&2,&4]));
/// ```
// Combinations works recursively, with each level handling one of the input sets.
// The idea is that the combinations of {[1,2], [3,4], [5,6]} can be generated by taking all
// combinations of {[1,2], [3,4]} and appending to each combination the values 5 and 6 in
// respective iterations.
// Therefore the Combinations object for {[1,2], [3,4], [5,6]} contains the values [5,6] (`values`),
// an iterator which remembers if the next value is 5 or 6 (`iter`), a Combinations object for
// {[1,2], [3,4]} (`internal`) and the last value returned by `internal` (`current`).
pub struct Combinations<I: IntoIterator> {
    // Lower levels in the recursion chain, if any
    internal: Option<Box<Combinations<I>>>,
    // The values added at this level in the chain
    values: I,
    // The values returned last by the lower levels iterator
    current: Vec<I::Item>,
    // An iterator over the values to add at this level
    iter: I::IntoIter,
}
impl<I> Combinations<I>
where
    I: IntoIterator + Clone,
    I::Item: Clone,
{
    /// Constructs a new `Combinations` object from the sets passed in `data`
    ///
    /// # Examples
    ///
    /// Owned sets:
    /// ```
    /// use helac_rs::util::Combinations;
    ///
    /// let combinations = Combinations::new(vec![vec![1,2], vec![3,4]]);
    /// ```
    ///
    /// Borrowed sets:
    /// ```
    /// use helac_rs::util::Combinations;
    ///
    /// let combinations = Combinations::new(vec![&[1,2], &[3,4]]);
    /// ```
    ///
    /// # Panics
    ///
    /// If `data` is empty
    /// ```should panic
    /// // This is not okay
    /// let combinations = Combinations::new(vec![]);
    /// ```
    /// or if any of the sets contained in `data` is empty
    /// ```should panic
    /// // and neither is this
    /// let combinations = Combinations::new(vec![vec![1,2],vec![]]);
    /// ```
    pub fn new(data: Vec<I>) -> Combinations<I> {
        Combinations::new_from_iter(data.into_iter())
    }

    /// Constructs a new `Combinations` object from the sets returned by the iterator `data`.
    ///
    /// # Examples
    ///
    /// ```text
    /// use helac_rs::util::Combinations;
    ///
    /// let data = vec![vec![1,2], vec![3,4]];
    /// let combinations = Combinations::new_from_iter(data.into_iter());
    /// ```
    ///
    /// # Panics
    ///
    /// If `data` is empty or if any of the sets contained in `data` is empty
    /// (see the documentation for `new` for examples)
    /// ```
    fn new_from_iter<II: Iterator<Item = I>>(mut data: II) -> Combinations<I> {
        let mut combinations = match data.next() {
            None => panic!("BUG: Empty combinations!"),
            Some(i) => Combinations::leaf(i),
        };
        for i in data {
            combinations = Combinations::node(combinations, i);
        }
        combinations
    }
    /// Creates intermediate levels in the recursion chain.
    ///  `internal` is the Combinations object that creates the combinations of all lower
    /// levels
    fn node(mut internal: Combinations<I>, data: I) -> Combinations<I> {
        let current = match internal.next() {
            Some(c) => c,
            None => panic!("BUG: Empty item in combinations"),
        };
        Combinations {
            internal: Some(Box::new(internal)),
            values: data.clone(),
            current,
            iter: data.into_iter(),
        }
    }
    /// Creates the last level in the recursion chain, the only one that does not contain any
    /// internal `Combinations`
    fn leaf(data: I) -> Combinations<I> {
        Combinations {
            internal: None,
            values: data.clone(),
            current: Vec::new(),
            iter: data.into_iter(),
        }
    }
}
impl<I> Iterator for Combinations<I>
where
    I: IntoIterator + Clone,
    I::Item: Clone,
{
    type Item = Vec<I::Item>;
    fn next(&mut self) -> Option<Vec<I::Item>> {
        if let Some(n) = self.iter.next() {
            // There is a value from `values` that has not been added to `current` yet.
            // Return this combination for this iteration step.
            let mut next = self.current.clone();
            next.push(n);
            return Some(next);
        }
        // All values from `values` have been added to `current` and returned
        // Check if `current` can be updated from `internal` if so, repeat the whole process,
        // if not the iteration ends
        if let Some(c) = self.internal.as_mut().and_then(|c| c.next()) {
            self.current = c;
            self.iter = self.values.clone().into_iter();
            return self.next();
        }
        None
    }
}

#[cfg(test)]
mod test {
    use super::Combinations;

    #[test]
    fn single() {
        let result: Vec<_> = Combinations::new(vec![vec![1, 2]]).collect();
        assert_eq!(result, vec![vec![1], vec![2]]);
    }

    #[test]
    fn double() {
        let result: Vec<_> = Combinations::new(vec![vec![1, 2], vec![3, 4]]).collect();
        assert_eq!(result, vec![vec![1, 3], vec![1, 4], vec![2, 3], vec![2, 4]]);
    }

    #[test]
    fn triple() {
        let result: Vec<_> =
            Combinations::new(vec![vec![1, 2], vec![3, 4], vec![5, 6, -1]]).collect();
        assert_eq!(
            result,
            vec![
                vec![1, 3, 5],
                vec![1, 3, 6],
                vec![1, 3, -1],
                vec![1, 4, 5],
                vec![1, 4, 6],
                vec![1, 4, -1],
                vec![2, 3, 5],
                vec![2, 3, 6],
                vec![2, 3, -1],
                vec![2, 4, 5],
                vec![2, 4, 6],
                vec![2, 4, -1],
            ]
        );
    }

    #[test]
    fn single_one() {
        let result: Vec<_> = Combinations::new(vec![vec![1]]).collect();
        assert_eq!(result, vec![vec![1]]);
    }

    #[test]
    fn triple_one() {
        let result: Vec<_> = Combinations::new(vec![vec![1, 2], vec![3], vec![5, 6, -1]]).collect();
        assert_eq!(
            result,
            vec![
                vec![1, 3, 5],
                vec![1, 3, 6],
                vec![1, 3, -1],
                vec![2, 3, 5],
                vec![2, 3, 6],
                vec![2, 3, -1],
            ]
        )
    }
}
